package ch2.hyungjun._02;

import java.time.LocalDateTime;

public class Screening {
    private Movie movie;   // instanc 변수의 가시성은 private, 메서드의 가시성은 public ==> 캡슐화를 통해 객체의 자율성 확보
    private int sequence; // 경계의 명확성이 객체의 자율성을 보장한다. ==> 프로그래머에게 구현의 자유를 제공한다.
    private LocalDateTime whenScreened;

    public Screening(Movie movie, int sequence, LocalDateTime whenScreened) {
        this.movie = movie;
        this.sequence = sequence;
        this.whenScreened = whenScreened;
    }

    public LocalDateTime getStartTime() {    //상영 시작시간
        return whenScreened;
    }

    public boolean isSequence(int sequence) {    // 순서
        return this.sequence == sequence;
    }

    public Money getMovieFee() {    //영화값
        return movie.getFee();
    }

   private Money calculateFee(int audienceCount) {
        return movie.calculateMovieFee(this).times(audienceCount);
    }
    public Reservation reserve(Customer customer, int audienceCount) {     // 예매하면 정보 반환
        return new Reservation(customer, this, calculateFee(audienceCount), audienceCount);
    }
}


// 요구사항

// 1. 하나의 영화는 하루 중 다양한 시간대에 걸쳐 한 번 이상 사용될 수 있다.
// 2. 특정한 규칙을 만족하는 예매자는 요금을 할인 받을 수 있다.
// 3. 영화별로 하나의 할인 정책만 할당할 수 있다. (minus 할인 or percent 할인 중에 무조건 하나만 가능)
// 4. 할인 정책을 지정하지 않는것도 가능 (할인 적용 x -> 기본요금 지불)
// 5. 할인 조건은 다수의 할인 조건 함께 지정가능, 순서,기간 조건 섞기 가능 (다양한 할인 조건중에 최소 1개의 할인조건만 만족해도 할인 가능)
// 6. 할인 조건 여러개를 만족해도 조건 하나당 중복으로 할인이 적용되지는 않는것 같음.
// 7. 할인 적용은 1인에 해당 (n명이면 (1인 할인액 * n) 이 총 할인액)

// ---------------
// 8. 예매 완료 후 예매 정보 생성 (제목, 상영정보, 인원, 정가, 결제금액)

// 조건의 종류 : 1. 할인 조건 (할인을 받을수 있는지 없는지)   /  2. 할인 정책 (할인의 방식 선정)

// 할인 조건 : 1. 순서 조건 (n번째 상영되는 영화)  /  2. 기간 조건 (특정 요일, 시작시간 ~ 종료시간 안에 조건을 만족하는지)
// 할인 정책 : 1. 금액 할인 정책 ( minus ) 2. 비율 할인 정책 ( percentage )

//-----------------

// 진정한 객체 지향에 다가가는법

// 1. 클래스 기반의 언어를 다루더라도 어떤 클래스가 필요한지를 고민하기 전에 어떤 객체들이 필요한지 고민하자.

// 클래스는 공통적인 상태와 행동을 공유하는 객체들을 추상화 한것이다.
// => 이 말을 해석해보면 클래스를 내에 다양한 객체들이 존재하게 되는데 결국 클래스는 이 객체들간의 협력을 통해 만들어내고자 하는 행위나 의도를 하나의 의미 단위로
// 표현해 주는 것이기 때문에 클래스를 고민하고 객체를 고민하는것이 아니라 객체를 먼저 고민하고 클래스의 윤곽(표현하고자하는 의미단위) 를 결정해라. 예를 들어보자면
// 새로운 요리를 창작하려고하는데 요리 이름을 지어놓고 재료선정을 하는게 맞냐? 재료들을 먼저 준비하고 만들고 나서 요리이름을 정하는 것이 맞냐? 이런 느낌으로
// 받아 들였다. 미리 재료(객체)들을 어떻게 조합할지 생각하면 만들어보고자 하는 요리이름(클래스)를 더 효과적이고 효율적으로 지을 수 있을 것!

// 2. 객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야한다.

// 객체의 의존도를 낮추고 자율성을 높여주는 것을 지향해야한다는 사실에 매몰되어 객체가 아예 독립적이어야 좋다고는 생각하지 말자. 이것 역시 요리로 예를 들면
// 요리를 할때, 이상적인 맛을 내려면 각 재료(객체)마다 들어가야하는 양과 정도의 차이가 존재한다. 어떤 재료는 어떤재료와 어울리게끔 조화로움를 고려해서
// 음식 맛의 밸런스를 설계하는 것 처럼 객체 역시 각 재료의 본연의 맛이나 식감이 살아나고 돋보이면 좋은 부분과 다른재료와 조화를 이뤘을때 맛이 좋아지는게 재료의
// 상태나 특성에 따라 다르다. 이것처럼 객체 역시 어느정도 자율성을 가져야 할 부분은 자율성을 높여주고 협력을 해야할 부분은 협력을 시켜주어 상황에 따라 유연한
// 좋은 밸런스를 가진 클래스를 만들수 있게 해줘야 한다.

// 도메인(domain) 이란?

// 문제를 해결하기 위해 사용자가 프로그램을 사용하는 분야 (사실상 실제 상황에서 문제 해결을 위한 요구 사항 로직)

// 객체지향이 강력한 이유가 도메인과 프로그램을 객체라는 관점에서 동일하게 볼수 있기 때문! 결국 객체를 구현하는 과정이 도메인내의 요구사항을 해결하는 과정과
// 일맥상통한다.
// ==> 클래스의 구조는 도메인의 구조와 유사한 형태를 띄어야 한다.

//-----------------------

// 객체는 상태(state)와 행동(behavior)을 함께 가지는 복합적인 존재다.
// 객체는 사실 스스로 판단하고 행동하는 자율적인 존재다. (사물이어도 의인화)

// 캡슐화 ==> 데이터와 기능을 객체 내부로 함께 묶는 것 ==> 나아가 접근 수정자(access modifier)를 이용해 접근제어(access control)를 한다.
// 우리가 지금까지 본것은 데이터를 숨기고 기능만 접근이 가능하게 한다.
// ==> 객체 스스로 상태 관리, 판단, 행동하는 자율적인 객체를 지향 => 이런 객체들의 공동체를 지향 ==> 객체지향의 핵심
// ==> 다른 객체가 요청을 할 수 있는 권한만 준다. 내가 자율적 이라는 의미 => 상대방이 나에 비해 상대적으로 수동적인 입장으로 변한다는 의미 => 다른 객체는
// 한 객체에 접근해서 요청을 하고 그 객체의 판단과 행동을 기다리는 수동적인 존재가 된다.

// 캡슐화와 접근제어는 객체를 두 부분으로 나눈다.

// 1. 인터페이스(public interface)
// 외부에서 접근이 가능한 부분

// 2. 구현(implementation)
// 외부에서 접근 불가능하고 오직 내부에서만 접근 가능한 부분

// ==> 인터페이스와 구현의 분리 원칙 => 좋은 객체지향을 위한 핵심 원칙


// 구현 은닉(implementation hiding)

// 프로그래머의 역할 : 1. 클래스 작성자 / 2. 클라이언트 프로그래머

// 클래스 작성자는 새로운 데이터 타입을 프로그램에 추가 / 클라이언트 프로그래머는 클래스 작성자가 추가한 데이터 타입 사용
// 클라이언트 프로그래머스는 예를 들면 밀키트 레시피만 사용하는 역할 / 클래스 작성자는 레시피를 생각해서 밀키트의 재료를 구성하는 사람









